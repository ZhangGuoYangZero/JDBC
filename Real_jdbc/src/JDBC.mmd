Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# jdbc

## JDBC<br/>是一组抽象的数据库操作集合

### 独立于数据库的数据库管理系统

### JDBC驱动<br/>真正实现了JDBC的内部具体操作，系统就是调用的这个

### JDBC的实现是厂商做的<br/>而普通人就只是调用接口

#### connection

#### statement

#### resultSet

#### Driver<br/>驱动

#### 额外注意，由于导入了JAR包进入了项目<br/>所以当你取寻找对应的包，就可以寻找到自己和导入的包，感觉写的很迷糊<br/>比如 com\.zgy\.xxx 这是由于自己的包就是这样

### 链接方法

#### 方法一

##### 这种方法是直接NEW 第三方的包

###### Driver driver = new com\.mysql\.cj\.jdbc\.Driver\(\);<br/>        System\.out\.print\(driver\);

#### 方法二

##### Driver通过加载也是就是反射的放射的方式实例化对象进入内部

###### Class DriverClass = Class\.forName\("com\.mysql\.cj\.jdbc\.Driver"\);<br/>     Driver driver = \(Driver\) DriverClass\.getDeclaredConstructor\(\)\.newInstance\(\);<br/>     System\.out\.print\(driver\);

#### 通过Driver对象获取的connnection方法获取connect对象<br/>一个connectio对象等于一个外模式也就是查询控制台

##### connect\(url,Properties info\)<br/>user password

#### 方法三，通过DriverManager去获取和管理<br/>推荐方法

##### DriverManager的构造器被私有了，只有通过Regesity方法<br/>Register方法里面加载了驱动，这个驱动已经是实例化被加载到里面了<br/>DriverManager就是进行了管理

######  DriverManager\.registerDriver\(\(Driver\) Class\.forName\("com\.mysql\.cj\.jdbc\.Driver"\)\.getDeclaredConstructor\(\)\.newInstance\(\)\);

##### 由于已经注册是驱动，所以可以直接通过管理器链接<br/>没有通过properties设置，是由于底层调用了一个properties

######  Connection conn = DriverManager\.getConnection\("jdbc:mysql://localhost:3306/jdbc","zgy","123456"\);<br/>        System\.out\.println\(conn\);

#### 方法四 ，由于mysql驱动在自动加载的时候，就帮忙做了注册<br/>所以直接用driverManager管理就好<br/>在加载的静态代码块自动给NEW一个Driver类对象，而这个Driver类对象就是MYSQL<br/>只是他的Driver的构造函数是空的

#####  Class\.forName\("com\.mysql\.cj\.jdbc\.Driver"\);<br/>        DriverManager\.getConnection\("jdbc:mysql://localhost:3306/jdbc","zgy","123456"\);

#### 方法五：全部通过Properties文件完成，需要的参数配置<br/>推荐

##### 使用 主类\.class\.getResourceAsStream（“url”） inputstream

###### 默认识别src下的

##### 通过之前NEW的properties的load方法加载

######  public void getConnection5\(\) throws IOException \{<br/>        Properties properties = new Properties\(\);<br/>        InputStream inputStreamProperty = ClassLoader\.getSystemClassLoader\(\)\.getResourceAsStream\("conf\.properties"\);<br/>        properties\.load\(inputStreamProperty\);

###### ClassLoader类加载器类  去 通过获取系统的类加载器

#### 路径 第三方\-类加载\-数据管理对象\-\-类自动加载\-properties自动配置

### 一个connection就是一个SOCKET链接<br/>无论他是链接远端还是本机的

### crud

#### 只能用于值类型<br/>不能用于表名，字段名，关键字

### BLOB

#### 写入数据库是用的setblob\(x,输入流\)

#### 读出数据是从getblob返回的对象中的方法getbinaryStream\(\)<br/>返回一个输入流

### batch批量处理

#### 由于不支持，需要设置下

##### 需要在driverPath后面添加参数<br/>？rewriteBatchedStatements=True

##### 5\.1\.37之后都支持了

### 写代码技巧，被调用的都是用throws<br/>最上层调用的用trycatch

### 事务

#### 事务是一组逻辑操作单元

#### 那些操作会导致数据的自动提交<br/>DDL 会自动提交<br/>DML 默认自动，可以手动提交

#### 默认关闭connection链接会自动提交

#### 可以在代码级别设置数据库为<br/>读已经提交<br/>修改一直有效

##### 重启mysql服务会自动重置为读未提交

### 泛型和反射都是在未知要返回什么的<br/>时候使用的，比如count\(\*\) 聚合函数之类

### 通用的方法被写成BASEDAO的方法了，让子类去继承<br/>而特俗的方法或者直接把所有方法全写成接口文件。让子类去继承接口，实现接口，尽管内部还是调用的BASEDAO的方法<br/>。如果有特俗用法只需要在父类上面添加一个泛型，让子类去获取这个泛型就可以了。（当然这里没说清楚，父类泛型 父类CLass 对象， DAO中运行了这个CLASS对象生成对象，这样不用额外写代码，怎么获取？使用反射）

### 数据接链接池技术

#### 传统的JDBC链接无法解决问题：<br/>1\.每次一个用户发起请求就要使用一次CONN去链接和关闭<br/>2\.一但某一个问题，该链接请求的资源不会释放<br/>3\.无法控制访问人数

#### 有一个缓存作用，并且可以重复利用，不在一直申请，一直释放

#### 开发常用Druid

##### DATASOURCE<br/>包含连接池和连接池管理<br/>取代了manager管理

##### 自己导入JAR包或者用MAVEN<br/>输入流读取是项目下开始读取<br/>而反射从src文件夹下开始

##### JDK内部定义了一些接口<br/>而第三方实现了它

###### 执行增删改查使用APACHA提供的DBUTILS的包<br/>这个包是开源的的集成了一些通用的操作

###### commons\-dbutils

####### RequqeryRun<br/>ResulSetHandle

######## 

##### JDBC: 原生访问数据库的方式, 其它三个都是对 JDBC 不同程度的封装 访问数据库比较麻烦, 代码重复度极高<br/>DbUtils: 是对JDBC进行了相对简单的封装, 主要就是能自动封装查询结果集, 需要在代码中写 sql 语句<br/>Mybatis: 进一步封装 JDBC, Sql 语句写在配置文件中, 面向对象操作, 有一 二级缓存功能<br/>Hibernate: 对 JDBC 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL
